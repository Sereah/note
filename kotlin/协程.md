### 协程上下文CoroutineContext

```kotlin
val defaultScope =
    CoroutineScope(SupervisorJob() + CoroutineName("hello Default") + Dispatchers.Default + CoroutineExceptionHandler { context, e ->
    })
```

1. Job, 控制协程的生命周期，一般使用`Job()`或者`SupervisorJob()`。
   - `Job()`：子协程失败会取消父协程和兄弟协程
   - `SupervisorJob()`：子协程失败不影响其他协程

2. CoroutineName，给协程上下文命名，默认是NULL，调试方便。

3. Dispatchers，将协程调度到不同类型的线程。
   - `Dispatchers.Default`: cpu密集型计算场景，使用共享线程池(固定大小，线程数=CPU核心数)
   - `Dispatchers.IO`: 耗时操作场景，使用动态扩展线程池(优先使用共享线程池)
   - `Dispatchers.Main`: 主线程
   - `Dispatchers.Unconfined`: 不推荐

4. CoroutineExceptionHandler，协程上下文异常处理

```Kotlin
val thread: Thread get() = Thread.currentThread()
val ioScope =
    CoroutineScope(SupervisorJob() + CoroutineName("hello IO") + Dispatchers.IO)

fun main(): Unit = runBlocking {

    launch {
        println("hello launch_1: $thread + ${coroutineContext[CoroutineName]} + ${coroutineContext[Job]}")
    }

    launch(ioScope.coroutineContext) {
        println("hello launch_2: $thread + ${coroutineContext[CoroutineName]} + ${coroutineContext[Job]}")
    }
}

//输出：
hello launch_2: Thread[#30,DefaultDispatcher-worker-1,5,main] + CoroutineName(hello IO) + StandaloneCoroutine{Active}@4e9f373
hello launch_1: Thread[#1,main,5,main] + null + StandaloneCoroutine{Active}@305fd85d
```

### 启动协程

#### runBlocking

连接了常规`fun main()`的非协程世界和`runBlocking { ... }`大括号内的协程代码, 会阻塞当前线程直到所有内容执行完成。
> 仅在测试中使用，生产代码用不到。

#### launch

`public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job`
当前协程的扩展方法，在当前协程下启动一个新的协程，返回的是Job对象，出现异常立刻传播，适用于不需要返回值的场景。

```kotlin
    val job = launch {
        println("launch_1: ${coroutineContext[Job]}")
    }
    println("job: $job")

//输出：
job: StandaloneCoroutine{Active}@1f7030a6
launch_1: StandaloneCoroutine{Active}@1f7030a6
```

#### async

`public fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>`
当前协程的扩展方法，在当前协程下启动一个新的协程，返回`Deferred<T>`, 使用`deferred.await()`获取结果，异常在await时才会传播。

```kotlin
    val deferred = async {
        delay(2000)
        "hello, sync"
    }
    deferred.await()
```

#### coroutineScope和supervisorScope
`public suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R`
`public suspend fun <R> supervisorScope(block: suspend CoroutineScope.() -> R): R`

挂起函数，上下文只能继承于父协程，主要作用是控制包含的子协程。
- coroutineScope：子协程失败则所有取消
- supervisorScope：子协程失败不影响其他协程

```kotlin
    coroutineScope {
        println("coroutineScope: start")
        launch {
            delay(2000)
            println("normal...")
        }
        launch {
            throw Exception("error...")
        }
        println("coroutineScope: end")
    }

//输出：
使用coroutineScope时，println("normal...")并不会执行，因为第二个子协程抛了异常。
将coroutineScope替换为supervisorScope，异常仍然抛，但是println("normal...")仍然会执行。
```

#### withContext

`public suspend fun <T> withContext(
    context: CoroutineContext,
    block: suspend CoroutineScope.() -> T
): T`
挂起函数，相比coroutineScope和supervisorScope多了协程上下文参数，一般传入协程调度器切换协程所在的线程

```kotlin
    println("global: ${coroutineContext[Job]}")
    withContext(Dispatchers.IO) {
        println("withContext: ${coroutineContext[Job]?.parent}")
    }

//输出：相同的job对象
global: BlockingCoroutine{Active}@51cdd8a
withContext: BlockingCoroutine{Active}@51cdd8a
```

#### GlobalScope

生命周期绑定应用进程的作用域，一般不使用它来开辟协程。


### 协程启动模式

`launch`和`sync`的声明中，除了协程上下文参数，还有一个CoroutineStart，代表协程的启动模式

#### CoroutineStart.DEFAULT

立即调度，可以立刻取消。

#### CoroutineStart.LAZY

不会立即调度，需要显示的使用Job的start(),join(),await()才会启动，可以立刻取消。

#### CoroutineStart.ATOMIC

立即调度，但是不能立刻取消，需要执行到第一个挂起点才行。

```kotlin
    val job = launch(start = CoroutineStart.ATOMIC) {
        println("launch----1---")
        delay(1000)
        println("launch--2-----")
    }
    job.cancelAndJoin()

//输出，会打印"launch----1---"，换成DEFAULT的话就不会打印。
```

#### CoroutineStart.UNDISPATCHED

立即在当前线程执行，直到第一个挂起点后，在根据调度器去切换线程或者在其他上下文执行。

```kotlin
   launch(start = CoroutineStart.UNDISPATCHED, context = Dispatchers.IO) {
        println("launch_1 thread: $thread")
        delay(1000)
        println("launch_2 thread: $thread")
   }
   println("main....")
//输出：第一个日志打印会现在主线程执行，到达第一个挂起点delay时再根据传入的调度器切换到线程池。
launch_1 thread: Thread[#1,main,5,main]
main....
launch_2 thread: Thread[#31,DefaultDispatcher-worker-1,5,main]
```

### 协程的生命周期































