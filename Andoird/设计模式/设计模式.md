## 创建型模式

### 单例模式

#### 场景

- 唯一实例

#### 使用

- `object class`

#### 举例

- Application

### 工厂方法模式

#### 场景

- 让子类决定实例化哪个类，解耦，遵从开闭原则(对扩展开放，对内修改关闭)。

#### 使用

1. 将多个业务类抽象一个接口。
2. 定义一个Factory抽象类，包含一个构建具体业务类对象的抽象方法create()。
3. 为每个业务类写一个构造工厂类，在create()中构造具体的业务类对象。
4. 使用端只需要构造构造工厂类对象，即可操作对应的业务类对象。

#### 举例

- ViewModel的Factory

### 抽象工厂模式

#### 场景

- 将同一类型对象作为一个家族，使用同一个工厂创建，易于扩展不同的家族，但不易于扩展家族内的元素。

#### 使用

1. 多个同类型的业务类作为一个家族
2. 定义一个抽象工厂，每个函数需要分别构造家族内的业务类对象。
2. 根据不同的使用场景，重写抽象工厂，在不同的使用场景构造业务类对象。
3. 使用端通过切换不同的构造工厂就可以获得不同场景下的一系列对象。

#### 举例

1. 主题切换：一套UI控件作为一个家族，分别在白天/黑夜模式下使用对应的工厂构造不同的控件对象。
2. 多数据源切换


### 建造者模式

#### 场景

- 分步构造复杂对象，链式调用。

#### 使用

1. 业务类中新建一个Builder内部类，属性和业务类需要的构造的参数一致。
2. Builder类中为每个属性设置一个set方法并返回builder自己。
3. Builder类中设置一个build函数，传入属性构造业务类对象，并返回业务类对象。
4. 使用端通过业务类.Builder来设置属性，最后.build()来获取业务类对象。

#### 举例

- AlertDialog

### 原型模式

#### 场景

##### 浅拷贝

- 复制对象本身及其值类型字段，但引用类型(list, map...)只复制引用地址。

- 影响：新的拷贝对象修改引用类型字段也会影响原对象的数据。

- Kotlin数据类中的copy()和Java中Cloneable接口的copy native函数都是浅拷贝。

##### 深拷贝

- 将引用数据类型中的元素也拷贝一份，如果引用数据类型中还有引用数据类型，也要全部拷贝。

- 深拷贝一般需要重写copy函数。

#### 使用

1. Java中将一个数据类实现Cloneable接口，重写clone方法，返回super.clone()使用默认浅拷贝，拿到super.clone()后的对象再替换引用字段，则可以实现深拷贝。
2. Kotlin不能重写数据类的copy()函数，深拷贝就需要自定义一个函数。

## 结构型模式

### 适配器模式

#### 场景

- 将不兼容的接口适配为期望的接口。

#### 使用

1. 定义一个接口，接口的方法是使用端需要的能力。
2. 定义一个Adapter类，实现接口，并持有期望能力类的对象(对象适配器)，或者继承这个类(类适配器)。
3. 使用端持有Adapter对象，调用接口的函数，不关心适配器怎么转换逻辑。
4. 同一个接口转换为不同的能力，就定义对应的适配器即可。
5. 更推荐对象适配器，类适配器会暴露期望能力类的其他公共函数。

#### 举例

- RecyclerView.Adapter


### 装饰者模式

#### 场景

- 不改变原有对象结构的情况下，动态增加新的职能。

#### 使用

1. 